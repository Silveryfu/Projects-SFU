#lang racket
(define nodes-created 0)                              ;use a global variable as counter of the nodes created

(define (kt-depth-first init-position n nodes-limit)
  (define board (make-array n))
  (define kt '())
  (write-chessboard(kt-depth-first-rec(cons init-position kt) n nodes-limit) board n))

(define (kt-depth-first-rec kt n nodes-limit)
  (set! nodes-created (add1 nodes-created))           ;increase the counter by one when a new node created
  (cond                                               
    [(goal-test kt n) kt]                             ;if goal reached
    [(equal? nodes-created nodes-limit) '(NaN)]       ;if maxumum reached, and not succeed
    [else (for/or ([i (possible-moves kt n)])         ;otherwise keep looking
          (kt-depth-first-rec (cons i kt) n nodes-limit))]
    ))
      
(define (possible-moves kt n)                         ;return all the possible-moves at current position
  (define r (car (car kt)))                           ;and here "moves" means the next POSITION
  (define c (cdr (car kt)))
  (get-valid-pos (set-diff (list
        (cons (- r 1) (- c 2)) (cons (- r 2) (- c 1)) 
        (cons (- r 1) (+ c 2)) (cons (- r 2) (+ c 1)) ;construct the list of 8 candidates
        (cons (+ r 1) (- c 2)) (cons (+ r 2) (- c 1)) ;and use the set-diff to get rid of
        (cons (+ r 1) (+ c 2)) (cons (+ r 2) (+ c 1)) ;visited positions
        ) kt) n))

(define (get-valid-pos candi n)                       ;get rid of the out-of-board positions
  (if (null? candi) '() 
      (if (and (and (>= (car (car candi)) 0)
           (< (cdr (car candi)) n)) (and (< (car (car candi)) n)
           (>= (cdr (car candi)) 0)))
           (cons (car candi) (get-valid-pos (cdr candi) n))
           (get-valid-pos (cdr candi) n))))

(define (goal-test kt n)
  (cond 
    [(>= (length kt) (* n n)) #t]
    [else #f]
    ))

(define (write-chessboard kt board n)
  (define count 1)
  (cond                           
    [(equal? kt #f) (display "No knight's tour exists!")]
    [(equal? kt '(NaN)) (display "Maximum trials reached!")]
    [(null? kt) 
     (begin
        (for ([i board])
          (if (equal? count 1) (display "((")
          (display " ("))
          (display (string-join (for/list ([j (vector->list i)]) 
                                  (~a j #:width (truncate (/ (* n n) 10)) #:align 'right))))
          (if (equal? count n) (displayln "))") (displayln ")"))
          (set! count (add1 count)))
        (display "Nodes created: <")
        (display nodes-created)
        (display ">"))]
    [else 
      (begin 
        (vector-set! (vector-ref board (car (car kt))) (cdr (car kt)) (length kt))     ;set the sequence    
        (write-chessboard (cdr kt) board n))]                                          ;number on board
      ))

;gadget functions

(define (set-diff l1 l2)
  (cond
    [(null? l1) '()]
    [(eq? (member (car l1) l2) #f)             
        (cons (car l1) (set-diff (cdr l1) l2))]
    [else (set-diff (cdr l1) l2)]))

(define (make-array n)              ;initialize an n*n matrix with 0
  (let ((a (make-vector n)))
    (let loop ((i 0))
      (when (< i n)
        (vector-set! a i (make-vector n))
        (loop (add1 i))))
         a))


 
;unit tests

(kt-depth-first '(0 . 0) 5 1000000)

;(make-array 5)

;(write-chessboard '((0 . 0) (0 . 1) (0 . 2) (0 . 3)
;                    (1 . 0) (1 . 1) (1 . 2) (1 . 3)       
;                    (2 . 0) (2 . 1) (2 . 2) (2 . 3)
;                    (3 . 0) (3 . 1) (3 . 2) (3 . 3)) (make-array 4))

;(possible-moves '((0 . 0)) 4)
  
;(set-diff '(a b c d) '(b d e))

;(goal-test '(1 2 3 4 5 6 7 8 9) 3) 