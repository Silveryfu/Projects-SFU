#lang racket
(define (kt-depth-first init-position n)
  (define board (make-array n))
  (define kt '())
  (write-chessboard(kt-depth-first-rec(cons init-position kt) n) board))

(define (kt-depth-first-rec kt n)
  (if (goal-test kt n) kt
      (for ([i (possible-moves kt n)])
        (kt-depth-first-rec (cons i kt) n)))
  )

(define (possible-moves kt n)       ;return all the possible-moves at current position
  (define r (car (car kt)))         ;and here "moves" means the next POSITION
  (define c (cdr (car kt)))
  (get-valid-pos (set-diff (list (cons (- r 1) (- c 2)) (cons (- r 2) (- c 1)) 
        (cons (- r 1) (+ c 2)) (cons (- r 2) (+ c 1)) ;construct the list of 8 candidates
        (cons (+ r 1) (- c 2)) (cons (+ r 2) (- c 1)) ;and use the set-diff to get rid of
        (cons (+ r 1) (+ c 2)) (cons (+ r 2) (+ c 1)) ;visited positions
        ) kt) n))

(define (get-valid-pos candi n)     ;get rid of the out-of-board positions
  (if (null? candi) '() 
      (if (and (and (>= (car (car candi)) 0)
           (< (cdr (car candi)) n)) (and (< (car (car candi)) n)
           (>= (cdr (car candi)) 0)))
           (cons (car candi) (get-valid-pos (cdr candi) n))
           (get-valid-pos (cdr candi) n))))

(define (goal-test kt n)
  (cond 
    [(>= (length kt) (* n n)) #t]
    [else #f]
    ))

(define (write-chessboard kt board)
  (if (null? kt) board 
      (begin (vector-set! (vector-ref board (car (car kt))) (cdr (car kt)) (length kt))
      (write-chessboard (cdr kt) board))
      )
  )

;gadget functions

(define (set-diff l1 l2)
  (cond
    [(null? l1) '()]
    [(eq? (member (car l1) l2) #f)             
        (cons (car l1) (set-diff (cdr l1) l2))]
    [else (set-diff (cdr l1) l2)]))

(define (make-array n)              ;initialize an n*n matrix with 0
  (let ((a (make-vector n)))
    (let loop ((i 0))
      (when (< i n)
        (vector-set! a i (make-vector n))
        (loop (add1 i))))
    a))

;unit tests

(kt-depth-first '(0 . 0) 5)


(make-array 5)

(write-chessboard '((0 . 0) (0 . 1) (0 . 2) (0 . 3)
                    (1 . 0) (1 . 1) (1 . 2) (1 . 3)       
                    (2 . 0) (2 . 1) (2 . 2) (2 . 3)
                    (3 . 0) (3 . 1) (3 . 2) (3 . 3)) (make-array 4))

(possible-moves '((0 . 0)) 4)
  
;(set-diff '(a b c d) '(b d e))

;(goal-test '(1 2 3 4 5 6 7 8 9) 3) 